import mimetypes
import gi
from soupsieve import select

gi.require_version("Gtk", "3.0")
from gi.repository import Gtk, Gio, Gdk, GLib, GdkPixbuf

import logging
import icotool
import os
import io
from pathlib import Path
from PIL import Image
from pprint import pprint
import configparser
import magic

import argparse


menu_def = '''
<interface>
  <menu id="preference_menu">
    <section>
      <item>
        <attribute name="label">New</attribute>
        <attribute name="action">win.new</attribute>
      </item>
      <item>
        <attribute name="label">Open</attribute>
        <attribute name="action">win.open_theme</attribute>
      </item>
      <item>
        <attribute name="label">Save</attribute>
        <attribute name="action">win.save</attribute>
      </item>
      <item>
        <attribute name="label">Save As</attribute>
        <attribute name="action">win.save_as</attribute>
      </item>
    </section>
    <section>
    <submenu id="base_theme_submenu">
      <attribute name="label" translatable="yes">_Base Theme</attribute>
      <section>
      </section>
    </submenu>
    </section>
    <section>
      <item>
        <attribute name="label">_Theme Options</attribute>
        <attribute name="action">win.theme_options_window</attribute>
      </item>
      <item>
        <attribute name="label">About</attribute>
        <attribute name="action">win.show_about</attribute>
      </item>
      <item>
        <attribute name="label">Quit</attribute>
        <attribute name="action">win.quit</attribute>
      </item>
    </section>
  </menu>
  <menu id="icon_context_menu">
    <section>
      <item>
        <attribute name="label">Icon Context</attribute>
        <attribute name="action">disabled</attribute>
      </item>
      <item>
        <attribute name="label">All</attribute>
        <attribute name="action">win.change-context</attribute>
        <attribute name="target">All</attribute>
      </item>
      <item>
        <attribute name="label">Typical</attribute>
        <attribute name="action">win.change-context</attribute>
        <attribute name="target">Typical</attribute>
      </item>
    </section>
  </menu>
  <menu id="right_click_menu">
    <section>
      <item>
        <attribute name="label">Copy</attribute>
        <attribute name="action">win.copy</attribute>
      </item>
      <item>
        <attribute name="label">Paste</attribute>
        <attribute name="action">win.paste</attribute>
      </item>
    </section>
  </menu>
</interface>
'''

ICONS = [
    "user-home", "go-home"
    "user-desktop",
    "user-trash",
    "user-trash-full",
    "drive-harddisk",
    "drive-harddisk-system",
    "media-removable",
    "drive-optical",
    "drive-removable-media",
    "media-floppy",
    "audio-x-generic",
    "folder",
    "text-x-generic",
    "video-x-generic",
    "system-file-manager",
    "utilities-terminal",
    "image-x-generic",
    "package-x-generic",
    "text-x-preview",
    "media-optical-dvd",
    "media-optical-cd-audio",
    "folder-documents",
    "folder-download",
    "folder-music",
    "folder-pictures",
    "folder-publicshare",
    "folder-remote",
    "folder-templates",
    "folder-videos",
    "network-server",
    "network-workgroup",
]


IMAGE_FILES = [
    "application/x-dosexec",
    "image/vnd.microsoft.icon",
    "image/png", "image/jpeg"
]

CONTEXTS = {
    #Name            Directory
    "Actions"      : "actions",
    "Animations"   : "animations",
    "Applications" : "apps",
    "Categories"   : "categories",
    "Devices"      : "devices",
    "Emblems"      : "emblems",
    "Emotes"       : "emotes",
    "International": "intl",
    "MimeTypes"    : "mimetypes",
    "Places"       : "places",
    "Status"       : "status",
    "Stock"        : "stock"
}

THEME_HEADER = '''[Icon Theme]
Name=GTK Theme Editor
Comment=This Theme Generated by GTK Theme Generator
Example=folder
Directories='''

BASE_THEME_DIRS = Gtk.IconTheme.get_default().get_search_path()

log = logging.getLogger('icotool')
formatter = logging.Formatter("[%(levelname)s] %(funcName)-25s: %(message)s")
handler = logging.StreamHandler()
handler.setFormatter(formatter)
#r.addHandler(logging.StreamHandler())

running_folder = os.path.dirname(os.path.abspath(__file__))
share_dir = running_folder
libexec_dir = running_folder

class IconTheme(Gtk.Application):
    def __init__(
        self, 
        filename=None, 
        show_symbolics=True, 
        context="Typical", 
        skip_legacy_context=True,
    ):

        logging.getLogger().handlers.clear()
        log.addHandler(handler)

        self.theme_file = filename
        self.show_symbolics = show_symbolics
        self.show_search = False

        self.icons_list = list()
        self.gtk_icon = None
        self.global_context = context
        self.skip_legacy = skip_legacy_context
        self.changes = dict()
        self.deleted = dict()
        self.theme_file_changes = dict()

        self.theme_name = ''
        self.theme_comment = ''


        self.theme_config_file = configparser.ConfigParser()
        self.theme_config_file.optionxform = str
        self.theme_config_file.read_string(THEME_HEADER)
        self.theme_file_path = filename


        self.settings = Gtk.Settings.get_default()
        self.system_theme = self.settings.props.gtk_icon_theme_name
        self.base_theme = self.system_theme
        self.selected_theme = None

        Gtk.Application.__init__(self,
                                 application_id="icon.theme",
                                 flags=Gio.ApplicationFlags.FLAGS_NONE)
        # https://developer.gnome.org/gio/unstable/GApplication.html#g-application-id-is-valid



        # GTK Settings

        self.handlers = {
        "Quit" : self.quit,
        "onDestroy": self.quit,
        "select_file": self.open_theme,
        "icon_selected": self.icon_selected,
        "open_search": self.on_key_event,
        "search_entry_search_changed": self.on_search_changed,
        "on_search_button_clicked" :self.on_search_button_clicked,
        "change_icon_clicked_cb" : self.choose_icon,
        "save_clicked_cb" : self.save,
        "on_key_press_event" : self.on_key_press_event,
        "on_select_icons_button_press_event" : self.show_right_click_menu,
        }
        
        self.builder = Gtk.Builder()
        self.builder.add_from_file(libexec_dir+"/icontheme.ui")
        self.builder.connect_signals(self.handlers)
        self.window = self.builder.get_object("main_window")
        self.available_icons = self.builder.get_object("available_icons")
        self.status_bar = self.builder.get_object("status_bar")
        self.context_id = self.status_bar.get_context_id("status_bar")
        self.searchbar = self.builder.get_object("search_bar")
        self._search_entry = self.builder.get_object("search_entry")
        #self.available_icon_themes = self.builder.get_object("available_icon_themes")
        self.search_button = self.builder.get_object("search_button")
        self.window.set_icon_from_file(str(Path(running_folder) / "icontheme.png"))
        # For copy/paste
        accel = Gtk.AccelGroup()
        accel.connect(Gdk.keyval_from_name('c'), Gdk.ModifierType.CONTROL_MASK, 0, self.copy)
        accel.connect(Gdk.keyval_from_name('v'), Gdk.ModifierType.CONTROL_MASK, 0, self.paste)
        self.window.add_accel_group(accel)
        self.clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)

        self.update_all_icons()
        self.build_menu_logic()
        #self.make_preferences_dialog()
        self.get_theme()
        self.update_available_icons()

        if self.theme_file_path:
            self.process_theme_file(self.theme_file_path)
            self.apply_theme()

        
        if not self.global_context:
            self.change_context_menu_radio.set_state(GLib.Variant("s", 'All'))

        self.window.show_all()

    def copy(self, *args):
        pixbufs = self.get_selected_pixbuf()
        if len(pixbufs) > 0:
            pixbuf = pixbufs[-1]
            log.debug('Copying to clipboard')
            self.clipboard.set_image(pixbuf)
    
    def paste(self, *args):
        image = self.clipboard.wait_for_image()
        icons_to_change = self.get_selected()
        if image is not None:
            self.replacement_images = list()
            self.replacement_icon_path = "Clipboard"
            w = image.get_width()
            h = image.get_height()
            # first square the image
            if w > h:
                squared = image.scale_simple(h, h, GdkPixbuf.InterpType.BILINEAR)
            else:
                squared = image.scale_simple(w, w, GdkPixbuf.InterpType.BILINEAR)
            
            dimensions = [16, 22, 24, 32, 48, 64, 96, 128, 256, 512]
            new_img = ''
            # if the size is not one of the support sizes, resize it (max is 512)
            if squared.get_height() not in dimensions:
                for i,d in enumerate(dimensions):
                    if squared.get_height() < d:
                        if i - 1 < 0:
                            i = 1
                        log.debug(f"Resizing pasted image to {dimensions[i-1]}x{dimensions[i-1]}")
                        new_img = squared.scale_simple(dimensions[i-1], dimensions[i-1], GdkPixbuf.InterpType.BILINEAR)
                        break
            if squared.get_height() > 512:
                new_img = squared.scale_simple(512,512, GdkPixbuf.InterpType.BILINEAR)
                log.debug(f"Resizing pasted image to 512x512")

            if new_img:
                image = new_img

            log.debug(f"New image from clipboard ({image.get_height()}x{image.get_width()})")
            self.replacement_images.append([image, image.get_height()])
            self.replace_icons()                
    

    def show_right_click_menu(self, widget, event):
        if event.type == Gdk.EventType.BUTTON_PRESS and event.button == 3:
            log.debug("Showing right click menu")
            self.right_click_menu_button.popup_at_pointer(event)
    
    def update_all_icons(self):
        gtk_icon = Gtk.IconTheme.get_default()
        contexts = gtk_icon.list_contexts()
        self.ALL_ICONS = {}
        for x in contexts:
            self.ALL_ICONS[x] = gtk_icon.list_icons(x)

    def get_theme_icons_all(self, icon_context=None):
        self.icons_list.clear()
        for context in self.ALL_ICONS:
            for icon in self.ALL_ICONS[context]:
                if ((not self.show_symbolics and "symbolic" in icon) 
                     # or  (self.skip_legacy and context == "Legacy"
                    ):
                    continue
                try:
                    pixbuf = self.gtk_icon.load_icon(icon, 64, Gtk.IconLookupFlags.FORCE_SIZE)
                except Exception as error:
                    log.error(f"Failed opening {icon}: {error}")

                filename = self.gtk_icon.lookup_icon(icon, 64, 0).get_filename()
                self.icons_list.append([pixbuf, icon , 0.5, context, filename])
        self.icons_list.sort(key=lambda x: x[1].casefold())

    def update_available_icons(self,filter=None):
        log.debug(f"Copying icons to available_icons GTK List store. Context: {self.global_context} Filter: {filter}")
        self.available_icons.clear()
        
        if not self.icons_list:
            self.get_theme_icons_all()

        for icon_item in self.icons_list:
            #print(f'{self.global_context} {self.global_context == "Typical"} and {icon_item[1]} {icon_item[1] in ICONS}')
            if ((self.global_context == "Typical" and icon_item[1] in ICONS) and 
                (not filter or icon_item[1].find(filter) >= 0)):
                
                self.available_icons.append(
                    [
                        icon_item[0].scale_simple(64, 64, GdkPixbuf.InterpType.BILINEAR), 
                        f"{icon_item[1]:.20}" , 
                        icon_item[2], 
                        icon_item[3],
                        icon_item[4],
                        icon_item[1]
                    ])
            else:
                # This if statement just checks for a filter and if context is set
                #log.debug(f"{self.global_context} {self.global_context in icon_item}")
                if ((not filter or icon_item[1].find(filter) >= 0) and
                     (not self.global_context or self.global_context in icon_item)):

                    self.available_icons.append(
                        [
                            icon_item[0].scale_simple(64, 64, GdkPixbuf.InterpType.BILINEAR), 
                            f"{icon_item[1]:.20}" , 
                            icon_item[2], 
                            icon_item[3],
                            icon_item[4],
                            icon_item[1]
                        ])
        self.update_status_bar(f"{len(self.available_icons)} Icons Loaded")

    def read_icons(self):
        self.update_available_icons()

    def get_theme(self):
        self.gtk_icon = Gtk.IconTheme.get_default()

    def quit(self, button, other=None):

        if self.builder.get_object("save").get_sensitive():
            response = self.save_or_not_dialog(True)
            if response == 2:
                self.save()
            elif response == -6: # Gtk.ResponseType.Cancel errors?
                return True
        Gtk.main_quit()

    def save(self, button=None, variant=None):
        log.debug(f"Current Theme File: {self.theme_file_path}")
        if not self.theme_file_path:
            self.save_as()
        else:
            self.save_all_changes(Path(self.theme_file_path).parent)


    def save_as(self, button=None, variant=None):
        
        dialog = Gtk.FileChooserDialog(
            title="Create new Icon theme folder",
            action=Gtk.FileChooserAction.SELECT_FOLDER,
        )

        dialog.add_buttons(
            Gtk.STOCK_CANCEL,
            Gtk.ResponseType.CANCEL,
            "Select",
            Gtk.ResponseType.OK)
        dialog.set_transient_for(self.window)

        dialog.set_local_only(False)
        dialog.set_modal(True)
        response_id = dialog.run()
        if response_id == Gtk.ResponseType.OK:
            selected_folder = dialog.get_filename()
            log.debug(f"Saving : {selected_folder}")
            dialog.destroy()
            
        elif response_id == Gtk.ResponseType.CANCEL:
            log.debug("File open cancelled")
            dialog.destroy()
            return
        else:
            log.debug("File chooser dialog closed")
            dialog.destroy()
            return
        
        icon_theme_folder = Path(selected_folder) / self.theme_config_file['Icon Theme']['Name'].lower().replace(" ","-")

        if icon_theme_folder.exists():
            response = self.theme_already_exists(theme_file_path_str = str(icon_theme_folder))
            if response == Gtk.ResponseType.NO:
                return
            else:
                self.rmdir(icon_theme_folder)
            
        self.save_all_changes(icon_theme_folder)

    def save_all_changes(self, folder):
        log.debug(f"Saving changes to '{str(folder)}'")

        folder.mkdir(parents=True, exist_ok=True)

        # if this is a save as we need to move the original theme over
        for name in self.theme_file_changes:
            for context in self.theme_file_changes[name]['Contexts']:
                for icon in self.theme_file_changes[name]['Icons']:
                    pixbuf, size, origin = icon
                    size_context_folder = f"{size}x{size}/{CONTEXTS[context]}"
                    log.debug(f"Checking: {size_context_folder}/{name}.png")
                    size_context_path = folder / size_context_folder
                    size_context_path.mkdir(parents=True, exist_ok=True)
                    if self.theme_config_file.has_section(size_context_folder):
                        log.debug(f"Section {size_context_folder} already exists in config")
                    else:
                        self.theme_config_file.add_section(size_context_folder)
                        self.theme_config_file[size_context_folder]['Context'] = context
                        self.theme_config_file[size_context_folder]['Size'] = str(size)
                        self.theme_config_file[size_context_folder]['Type'] = "Fixed"
                    size_context_name_path = size_context_path / f"{name}.png"
                    if not size_context_name_path.exists():
                        log.debug(f"Writting: {str(size_context_name_path)}")
                        pixbuf.savev(str(size_context_name_path),"png",[], [])

        # then we write the changes
        for name in self.changes:
            for context in self.changes[name]['Contexts']:
                for icon in self.changes[name]['Icons']:
                    pixbuf, size, origin = icon
                    size_context_folder = f"{size}x{size}/{CONTEXTS[context]}"
                    log.debug(f"Saving: {size_context_folder}/{name}.png")
                    size_context_path = folder / size_context_folder
                    size_context_path.mkdir(parents=True, exist_ok=True)
                    
                    if self.theme_config_file.has_section(size_context_folder):
                        log.debug(f"Section {size_context_folder} already exists in config")
                    else:
                        self.theme_config_file.add_section(size_context_folder)
                        self.theme_config_file[size_context_folder]['Context'] = context
                        self.theme_config_file[size_context_folder]['Size'] = str(size)
                        self.theme_config_file[size_context_folder]['Type'] = "Fixed"
                    
                    size_context_name_path = size_context_path / f"{name}.png"
                    log.debug(f"Writting: {str(size_context_name_path)}")
                    pixbuf.savev(str(size_context_name_path),"png",[], [])

            self.theme_file_changes[name] = self.changes[name]
                
                    

        self.theme_config_file['Icon Theme']['Inherits'] = f"{self.base_theme},hicolor"
        

        # update Directorie= entry and get largest icon size per context
        sizes = {}
        for section in self.theme_config_file.sections():
            if section not in ['Icon Theme']:
                if section not in self.theme_config_file['Icon Theme']['Directories']:
                    self.theme_config_file['Icon Theme']['Directories'] += f",{section}"
                
                size = self.theme_config_file[section]['Size']
                context = self.theme_config_file[section]['Context']
                
                if context not in sizes:
                    sizes[context] = size

                if int(sizes[context]) < int(size):
                    sizes[context] = size

        self.theme_config_file['Icon Theme']['Directories'] = self.theme_config_file['Icon Theme']['Directories'].lstrip(",")
        # Get largest icon and make it scaleable        
        for section in self.theme_config_file.sections():
            if section not in ['Icon Theme']:
                context = self.theme_config_file[section]['Context']
                size = self.theme_config_file[section]['Size']
                if sizes[context] == size:
                    self.theme_config_file[section]['MinSize'] = size
                    self.theme_config_file[section]['MinSize'] = '512'
                    self.theme_config_file[section]['Type'] = "Scalable"

        # Do we need to maybe delete some icons instead?
        for icon_name in self.deleted:
            for context in self.deleted[icon_name]:
                for section in self.theme_config_file.sections():
                    if section not in ['Icon Theme'] and context == self.theme_config_file[section]['Context']:
                        size = self.theme_config_file[section]['Size']
                        size_context_folder = folder / f"{size}x{size}" / CONTEXTS[context]
                        if size_context_folder.exists():
                            for file in size_context_folder.rglob(f"{icon_name}.*"):
                                log.debug(f"Deleting {str(file)}")
                                file.unlink()
            if icon_name in self.theme_file_changes:
                self.theme_file_changes.pop(icon_name, None)
        
        self.deleted = {}
        self.changes = {}


        with open(str(folder / "index.theme"), 'w') as index_theme_file:
            self.theme_config_file.write(index_theme_file, space_around_delimiters=False)
        
        self.save_button(False)

    def save_or_not_dialog(self, close=False):

        dialog = Gtk.Dialog(title="Save Changes", flags=0)

        dialog.set_default_size(150, 100)

        if close:
            text = "Close without saving?"
            dialog.add_buttons(
               Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,"Close Without Saving",1, "Save and Close", 2
            )
        else:
            text = "Open new theme without saving changes?"
            dialog.add_buttons(
                Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL, Gtk.STOCK_OK, Gtk.ResponseType.OK, "Save", 1
            )
        label = Gtk.Label(label=text)

        #label.set_halign(1)

        box = dialog.get_content_area()
        box.pack_start(label, True, True,0)
        dialog.show_all()
        r = dialog.run()
        dialog.destroy()
        return r

    def rmdir(self, directory):
        directory = Path(directory)
        for item in directory.iterdir():
            if item.is_dir():
                self.rmdir(item)
            else:
                item.unlink()
        directory.rmdir()    

    def open_theme(self, button=None, action=None):
        log.debug("Select Icon Theme File Button Pressed")


        if self.builder.get_object("save").get_sensitive():
            log.debug("Current changes not saved")
            response = self.save_or_not_dialog()
            if response == 1:
                self.save()
            elif response == -6: # Gtk.ResponseType.Cancel errors?
                return
        
        self.save_button(False)

        dialog = Gtk.FileChooserDialog(
            title="Please choose an Icon Theme file",
            action=Gtk.FileChooserAction.OPEN,
        )

        dialog.add_buttons(
            Gtk.STOCK_CANCEL,
            Gtk.ResponseType.CANCEL,
            "Select",
            Gtk.ResponseType.OK)

        file_filter = Gtk.FileFilter()
        file_filter.set_name("Icon Theme")
        file_filter.add_pattern("*.theme")
        file_filter.add_pattern("*.THEME")
        dialog.add_filter(file_filter)
        file_filter = Gtk.FileFilter()
        file_filter.set_name("All Files")
        file_filter.add_pattern("*")
        dialog.add_filter(file_filter)
        # not only local files can be selected in the file selector
        dialog.set_local_only(False)
        # dialog always on top of the textview window
        dialog.set_modal(True)
        # connect the dialog with the callback function open_response_cb()
        dialog.connect("response", self.open_theme_response)
        #always set open to start in home folder instead of recent
        if self.theme_file_path:
            dialog.set_current_folder(str(Path(self.theme_file_path).parents[0]))
        else:
            dialog.set_current_folder(str(Path.home()))
        # show the dialog
        dialog.show()

    def choose_icon(self, button=None, path=None):
            
        log.debug("Choose Icon button pressed")
        dialog = Gtk.FileChooserDialog(
            title="Please choose a file",
            action=Gtk.FileChooserAction.OPEN,
        )

        dialog.add_buttons(
            Gtk.STOCK_CANCEL,
            Gtk.ResponseType.CANCEL,
            "Select",
            Gtk.ResponseType.OK)

        file_filter = Gtk.FileFilter()
        file_filter.set_name("ICO/ICL/DLL/EXE")
        file_filter.add_pattern("*.ICO")
        file_filter.add_pattern("*.ico")
        file_filter.add_pattern("*.dll")
        file_filter.add_pattern("*.DLL")
        file_filter.add_pattern("*.ICL")
        file_filter.add_pattern("*.icl")
        file_filter.add_pattern("*.exe")
        file_filter.add_pattern("*.EXE")
        dialog.add_filter(file_filter)
        file_filter = Gtk.FileFilter()
        file_filter.set_name("All Files")
        file_filter.add_pattern("*")
        dialog.add_filter(file_filter)
        # not only local files can be selected in the file selector
        dialog.set_local_only(False)
        # dialog always on top of the textview window
        dialog.set_modal(True)
        # connect the dialog with the callback function open_response_cb()
        dialog.connect("response", self.open_icon_response)
        #always set open to start in home folder instead of recent
        # show the dialog
        dialog.show()  
    

        # callback function for the dialog open_dialog
    def open_theme_response(self, dialog, response_id):
        log.debug("Open file response")
        open_dialog = dialog
        # if response is "ACCEPT" (the button "Open" has been clicked)
        if response_id == Gtk.ResponseType.OK:

            log.debug("Response OK")
            self.theme_file_path = open_dialog.get_filename()
            dialog.destroy()
            log.debug(f"File selected: {self.theme_file_path}")
            self.process_theme_file(self.theme_file_path)
            self.apply_theme()
            

        # if response is "CANCEL" (the button "Cancel" has been clicked)
        elif response_id == Gtk.ResponseType.CANCEL:
            log.debug("File open cancelled")

            dialog.destroy()
        # destroy the FileChooserDialog

    def process_theme_file(self, theme_file_path):
        log.debug(f"Processing theme file: {theme_file_path}")
            
        try:
            theme_config_file = configparser.ConfigParser()
            theme_config_file.optionxform = str
            theme_config_file.read(theme_file_path)
        except Exception as error:
            self.invalid_theme_file(theme_file_path, f"Error: {error}")
            return

        self.theme_config_file = theme_config_file
        
        if not self.theme_config_file.has_section('Icon Theme'):
            self.invalid_theme_file(theme_file_path,"missing section 'Icon Theme'")
            return
        
        if not self.theme_config_file.has_option('Icon Theme','Comment'):
            self.invalid_theme_file(theme_file_path,"missing 'Comment' option in 'Icon Theme' section")
            return
        
        log.debug(f"Done injesting: {self.theme_file_path}")


    def apply_theme(self):

        if not self.theme_config_file.has_option('Icon Theme','Inherits'):
            inherits ='default'
        else:
            inherits = self.theme_config_file['Icon Theme']['Inherits'].split(",")[0].strip('"')

        log.debug(f"Theme is based on {inherits}")
        

        self.changes = dict()
        found = False

        for theme in self.available_themes:
            if self.available_themes[theme]['folder'] == inherits:
                found = True
                self.change_theme(self.change_context_action, GLib.Variant("s", theme))
                break

        if not found and inherits not in ['default','hicolor']:
            log.warning(f"Base theme: {inherits} from {self.theme_file_path} does not exist, using {self.base_theme}")
            self.warning_window(f"Base theme: {inherits} from {self.theme_file_path} does not exist, using {self.base_theme}")

        if inherits in ['default','hicolor']:
            log.debug(f'Theme inherits {inherits} not changing system base theme')
        
        
        
        # Load all the icons in the various folders in to a dict of lists: 
        #     { icon-name : [context, [pixbuf, size, filepath]] }
        theme_PATH = Path(self.theme_file_path).parent
        images_in_theme = (
                list(theme_PATH.glob(f"**/*.png")) + 
                list(theme_PATH.glob(f"**/*.PNG"))
            )

        self.theme_file_changes = dict()

        for image in images_in_theme:
            image_path = Path(image)
            name = image_path.stem
            context = image_path.parent.name
            try:
                size = image_path.parent.parent.name.split("x")[0]
            except:
                log.debug(f"Can't determine size of {str(image_path)}, skipping")
                continue

            if name not in self.theme_file_changes:
                self.theme_file_changes[name] = dict()

            if 'Contexts' not in self.theme_file_changes[name]:
                self.theme_file_changes[name]['Contexts'] = list()
            
            if 'Icons' not in self.theme_file_changes[name]:
                self.theme_file_changes[name]['Icons'] = list()
            
            for context_name, context_folder in CONTEXTS.items():
                if context_folder == context and context_name not in self.theme_file_changes[name]['Contexts']:
                    self.theme_file_changes[name]['Contexts'].append(context_name)
            
            if self.theme_icon_size_already_exists(size, self.theme_file_changes[name]['Icons']):
                # skip if the size is already in here
                # this isn't great if the theme has different icons of same name different contexts
                # but thats not best practice anyway
                continue

            pixbuf = GdkPixbuf.Pixbuf.new_from_file(str(image_path))
            self.theme_file_changes[name]['Icons'].append([pixbuf, size, str(image_path)])
        self.apply_theme_file_changes()

    def theme_icon_size_already_exists(self, size, icons_list):
        for row in icons_list:
            if size in row:
                return True
        return False
        
    def open_icon_response(self, dialog, response_id):
        log.debug("Open file response")
        
        magi = magic.Magic(mime_encoding=True, mime=True)
        open_dialog = dialog
        # if response is "ACCEPT" (the button "Open" has been clicked)
        if response_id == Gtk.ResponseType.OK:

            log.debug("Response OK")
            selected_file = Path(open_dialog.get_filename())
            mimetype = magi.from_file(str(selected_file)).split(";")[0]
            if mimetype in IMAGE_FILES:
                log.debug(f"Selected file type: {mimetype}")
                self.get_replacement_icons(selected_file, mimetype)
                if self.replacement_images:
                    self.replace_icons()
            else:
                dialog.destroy()
                self.wrong_image_file_error(str(selected_file), mimetype)
        # if response is "CANCEL" (the button "Cancel" has been clicked)
        elif response_id == Gtk.ResponseType.CANCEL:
            log.debug("File open cancelled")
        # destroy the FileChooserDialog
        dialog.destroy()

    
    def get_replacement_icons(self, selected_file, mimetype):
        ''' Gets one or more replacement images from ICO, ILC, DLL, EXE, PNG or JPG images
            Returns a list of lists with [pixbuf, dimension (64x64, 32x32, etc)]
            Selected_file is a Path object of the path to the file
            mimetype is a string of the mimetype
        '''

        # if the file is an image, check the image dimmensions
        #     if the dimensions are not square, square up the image
        #     otherwise if its not in 48, 64, 96, 128, 256 or 512
        #         resize it to fit the closest size
        # otherwise if its an ICON, ICL or DLL/EXE
        #     load the file
        #     if its an ICL/DLL/EXE popup a window to select the icon to use
        #     otherwise get the images

        self.replacement_images = list()
        self.replacement_icon_path = str(selected_file)

        if mimetype in ["image/png", "image/jpeg"]:
            self.process_image_file(selected_file)
        else:
            # The file is a ico, dll, exe, or icl
            try:
                self.replacement_icons_lib = icotool.IcoTool(str(selected_file))
            except:
                log.error(f"Error opening {str(selected_file)}")
            icon_data = self.replacement_icons_lib.extract_all()
            if self.replacement_icons_lib.icontype == "ICO":
                for icon in icon_data:
                    self.append_best_color_icon(icon)
            else:
                log.debug("Opening ICON selection window")
                icon_data = self.replacement_icons_lib.extract_best()
                log.debug(f"{len(icon_data)} icons available")
                self.select_icon_from_exec(icon_data)
                
    def process_image_file(self, image_file_path):
        # is the file an image?
            img = Image.open(str(image_file_path))
            # if the dimensions are not square, square them up with a resize
            if img.height != img.width:
                log.debug(f"Image {str(image_file_path)} not a square (w{img.width}, h{img.height}), resizing")
                if img.height > img.width:
                    img.resize((img.height, img.height))
                else:
                    img.resize((img.width, img.width))
            
            dimensions = [16, 22, 24, 32, 48, 64, 96, 128, 256, 512]
            new_img = ''
            # if the size is not one of the support sizes, resize it (max is 512)
            if img.height not in dimensions:
                for i,d in enumerate(dimensions):
                    if img.height < d:
                        if i - 1 < 0:
                            i = 1
                        log.debug(f"Resizing {str(image_file_path)} to {dimensions[i-1]}x{dimensions[i-1]}")
                        new_img = img.resize((dimensions[i-1], dimensions[i-1]))
                        break
            if img.width > 512:
                new_img = img.resize((512,512))

            if new_img:
                img = new_img
            log.debug(f"Image Icon dimensions: {img.width}x{img.height}")
            self.replacement_images.append([self.image2pixbuf(img), img.height])

    def on_key_press_event(self, widget, event):
        if Gdk.keyval_name(event.keyval) == 'Delete':
            for deleted_icon in self.get_selected():
                log.debug(f"Deleting: {deleted_icon[-1]}")
                self.delete_icon(deleted_icon[-1], deleted_icon[1] )

    def select_icon_from_exec(self, icon_data):
        log.debug("Creating Icon Selection Window")
        self.icon_select_window = Gtk.Window()
        self.icon_select_window.set_default_size(700, 400)
        icon_window = Gtk.ScrolledWindow()
        self.icon_view_liststore = Gtk.ListStore(GdkPixbuf.Pixbuf, int)
        self.iconview = Gtk.IconView.new()
        self.iconview.set_model(self.icon_view_liststore)
        self.iconview.set_pixbuf_column(0)
        self.iconview.set_text_column(-1)

        self.iconview.connect('item-activated', self.iconview_item_activated)
        icon_window.add(self.iconview)
        self.icon_select_window.add(icon_window)

        hb = Gtk.HeaderBar()
        hb.set_show_close_button(False)
        hb.props.title = "Select Replacement Icon"
        hb.set_subtitle(f"{Path(self.replacement_icons_lib.filename).name}")
        self.icon_select_window.set_titlebar(hb)

        button = Gtk.Button(label="Select")
        button.connect("clicked", self.iconview_item_activated)
        hb.pack_end(button)
        button = Gtk.Button(label="Cancel")
        button.connect("clicked", self.icon_view_cancel)
        hb.pack_start(button)


        for icon in icon_data:

            try:
                img = Image.open(io.BytesIO(icon['ICON']))
            except ValueError:
                log.debug(f"Unable to open icon {icon['filename']}")
                continue
            id = icon['ID']
            if 'index' in icon:
                id = icon['index']
            self.icon_view_liststore.append([self.image2pixbuf(img.resize((64,64))),int(id)])

        self.icon_select_window.show_all()

    def iconview_item_activated(self, selection, path=None):
        log.debug("New icon selected, getting images")

        for treeview in self.iconview.get_selected_items():
            treeiter = self.icon_view_liststore.get_iter(treeview)
            id = self.icon_view_liststore.get_value(treeiter, 1)
            
            for icon in self.replacement_icons_lib.extract_all():
                # Some icons in exe/Dlls have an index, whereas icon libraries (ICL) do not
                # this if statement gets the icon corresponding to an ID or Index (if it exists)
                if ("index" in icon and icon['index'] == id) or ("index" not in icon and 'ID' in icon and icon['ID'] == id):

                    log.debug(f"Found replacement Icon with index {id} {icon['filename']} Colors: {icon['Colors']}")
                    self.append_best_color_icon(icon)

        self.icon_select_window.destroy()
        self.replace_icons()

    def delete_icon(self, icon_name, context):
        log.debug(f"Name: {icon_name} Context: {context}")
        if icon_name in self.changes:
            log.debug("Removing Icon from Changes list")
            self.changes.pop(icon_name, None)

            if icon_name in self.theme_file_changes:
                self.apply_theme_file_changes()
                return

        elif icon_name in self.theme_file_changes:
            
            if icon_name not in self.deleted:
                self.deleted[icon_name] = list()

            if context not in self.deleted[icon_name]:
                log.debug(f"Removing from {str(self.theme_file_path)}")
                self.deleted[icon_name].append(context)
        
        else:
            log.debug("This Icon is part of the base theme and cannot be removed")
            return

        try:
            pixbuf = self.gtk_icon.load_icon(icon_name, 64, Gtk.IconLookupFlags.FORCE_SIZE)
        except Exception as error:
            log.error(f"Failed opening {icon_name}: {error}")

        filename = self.gtk_icon.lookup_icon(icon_name, 64, 0).get_filename()
        self.icons_list.append([pixbuf, icon_name , 0.5, context, filename])
        self.replace_icon_pixbuf(icon_name, pixbuf, filename)
        self.save_button(True)
    
    def append_best_color_icon(self, icon):
        '''
        Appends the best color icon. Oftentimes Icons will come with 32x32 16 bit, 32 bit, 256 bit color icons
        This makes sure only the best quality icon is added
        '''

        try:
            img = Image.open(io.BytesIO(icon['ICON']))
        except ValueError:
            log.error(f"Unable to open icon {icon['filename']}")
            return
            

        for i in range(len(self.replacement_images)):
            # We only want highcolor icons, the higher the better
            # this if statement checks if the image size already exists
            # and if it does, if the color in the current icon great than the one
            # already in the list
            if (self.replacement_images[i][1] == img.height and 
                self.replacement_images[i][2] < icon['Colors']):

                
                self.replacement_images[i] = [self.image2pixbuf(img), img.height, icon['Colors']]
                return
        
        self.replacement_images.append([self.image2pixbuf(img), img.height, icon['Colors']])

    def icon_view_cancel(self, button):
        self.icon_select_window.destroy()

    def wrong_image_file_error(self, image_path, mimetype):

            dialog = Gtk.MessageDialog(
                transient_for=self.window,
                flags=0,
                message_type=Gtk.MessageType.ERROR,
                buttons=Gtk.ButtonsType.OK,
                text="Invalid image file selected",
            )
            dialog.format_secondary_text(
                f"File: {image_path}\nMimetype: {mimetype}"
            )
            dialog.run()
            log.debug("Error Message Closed")
            dialog.destroy()

    def theme_already_exists(self, widget=None, theme_file_path_str=''):
        dialog = Gtk.MessageDialog(
            flags=0,
            message_type=Gtk.MessageType.QUESTION,
            buttons=Gtk.ButtonsType.YES_NO,
            text="Theme folder already exists.",
        )
        dialog.format_secondary_text(
            f"The Theme folder {theme_file_path_str} already exists. Do you wish to replace that folder? This will delete that folder and replace with the current changes."
        )
        response = dialog.run()
        dialog.destroy()
        return response

    def warning_window(self, warning):

            dialog = Gtk.MessageDialog(
                transient_for=self.window,
                flags=0,
                message_type=Gtk.MessageType.ERROR,
                buttons=Gtk.ButtonsType.OK,
                text="Warning",
            )
            dialog.format_secondary_text(
                f"{warning}"
            )
            dialog.run()
            dialog.destroy()

    def invalid_theme_file(self, theme_file_path, message):

            dialog = Gtk.MessageDialog(
                transient_for=self.window,
                flags=0,
                message_type=Gtk.MessageType.ERROR,
                buttons=Gtk.ButtonsType.OK,
                text="Invalid Icon Theme File",
            )
            dialog.format_secondary_text(
                f"File '{theme_file_path}' {message}"
            )
            dialog.run()
            log.debug("Error Message Closed")
            dialog.destroy()

    def replace_icons(self):   

        for selected_icon in self.get_selected():
            self.changes[selected_icon[3]] = dict()
            self.changes[selected_icon[3]]['Contexts'] = self.get_context(selected_icon[3])
            self.changes[selected_icon[3]]['Icons'] = list()
            for icon in self.replacement_images:
                self.changes[selected_icon[3]]['Icons'].append([icon[0], icon[1], self.replacement_icon_path])
        
        self.save_button(True)
        self.apply_changes()
            
    def apply_changes(self):
        
        log.debug("Applying changes to interface")
        # overlay custom changes over current theme
        for change in self.changes:
            size = 0
            for row in self.changes[change]['Icons']:
                if int(row[1]) > size:
                    size = int(row[1])
                    icon_pixbuf = row[0].scale_simple(64, 64, GdkPixbuf.InterpType.BILINEAR)
            log.debug(f"Applying new change to {change}")
            self.replace_icon_pixbuf(change, icon_pixbuf, self.replacement_icon_path)
        
    
    def apply_theme_file_changes(self):
        # if any exist apply theme file changes
        for change in self.theme_file_changes:
            size = 0
            for row in self.theme_file_changes[change]['Icons']:
                if int(row[1]) > size:
                    size = int(row[1])
                    icon_pixbuf = row[0].scale_simple(64, 64, GdkPixbuf.InterpType.BILINEAR)
            log.debug(f"Applying loaded theme file change to {change}: {row[2]}")
            self.replace_icon_pixbuf(change, icon_pixbuf, row[2])    

    def replace_icon_pixbuf(self, icon_name, pixbuf, new_icon_path):
        log.debug(f"Replacing {icon_name}")

        for i in range(len(self.icons_list)):
            if self.icons_list[i][1] == icon_name:
                log.debug(f"Replacing {self.icons_list[i][1]} with new icon")
                self.icons_list[i][0] = pixbuf

        treeiter = self.available_icons.get_iter_first()
        while treeiter:
            if self.available_icons.get_value(treeiter, 5) == icon_name:
                log.debug("Updating Iconview Window ")
                self.available_icons.set_value(treeiter, 0, pixbuf)
                self.available_icons.set_value(treeiter, 4, new_icon_path)
            treeiter = self.available_icons.iter_next(treeiter)

    def get_context(self, icon_name):
        contexts = list()
        for context in self.ALL_ICONS:
            if icon_name in self.ALL_ICONS[context] and context != "Legacy":
                contexts.append(context)
        return contexts

    def update_status_bar(self, message=""):

        self.status_bar.pop(self.context_id)
        self.status_bar.push(self.context_id, message)

    def icon_selected(self, icon=None):
        item = self.get_selected()

        if len(item) > 1:
            self.update_status_bar(f"{len(item)} icons selected")
            self.builder.get_object("change_icon_bar").set_sensitive(True)
            # self.builder.get_object("change_icon").set_label("Change Icons...")
        elif len(item) == 1:
            name,context,filepath,fullname = item[0]
            self.update_status_bar(f"Path: {filepath} Name: {fullname}, Context: {context}")
            log.debug(f"Name: {name}, Context: {context}, Path: {filepath}")
            self.builder.get_object("change_icon_bar").set_sensitive(True)
            # self.builder.get_object("revealer").set_reveal_child(True)
        else:
            self.update_status_bar()
            self.builder.get_object("change_icon_bar").set_sensitive(False)

    def get_selected(self):
        selected_icons = list()
        liststore = self.builder.get_object("available_icons")
        selected_items = self.builder.get_object('select_icons').get_selected_items()
        #windowlog.debug(f"Getting {len(selected_items)} selected icons")
        for treeview in selected_items:
            treeiter = liststore.get_iter(treeview)
            name = liststore.get_value(treeiter, 1)
            context = liststore.get_value(treeiter, 3)
            filepath = liststore.get_value(treeiter, 4)
            fullname = liststore.get_value(treeiter, 5)
            selected_icons.append((name,context,filepath, fullname))
            #log.debug(f"Name: {name}, Context: {context}")
        return selected_icons

    def get_selected_pixbuf(self):
        selected_icons = list()
        liststore = self.builder.get_object("available_icons")
        selected_items = self.builder.get_object('select_icons').get_selected_items()
        #windowlog.debug(f"Getting {len(selected_items)} selected icons")
        for treeview in selected_items:
            treeiter = liststore.get_iter(treeview)
            pixbuf = liststore.get_value(treeiter, 0)
            selected_icons.append(pixbuf)
            #log.debug(f"Name: {name}, Context: {context}")
        return selected_icons

    def on_search_button_clicked(self, button):
        self.toggle_bar()

    def show_bar(self, show):
        self.show = show
        if not self.show:
            log.debug("Closing search bar")
            self._search_entry.set_text('')
            self.searchbar.set_search_mode(False)
        else:
            log.debug("Showing search bar")
            self._search_entry.set_text('')
            self.searchbar.set_search_mode(True)

    def toggle_bar(self):
        self.show_bar(not self.searchbar.get_search_mode())

    def on_key_event(self, widget, event):
        keyname = Gdk.keyval_name(event.keyval)


        if keyname == 'Escape' and self.search_button.get_active():
            if self._search_entry.is_focus():
                self.search_button.set_active(False)
                self.searchbar.set_search_mode(False)
            else:
                self._search_entry.grab_focus()
            return True

        if event.state & Gdk.ModifierType.CONTROL_MASK:
            if keyname == 'f':
                self.search_button.set_active(True)
                return True

        return False

    def on_search_changed(self, widget):
        search_text = self._search_entry.get_text()
        log.debug(f"searching for {search_text}")
        self.update_available_icons(filter=search_text)

    def on_change_label_state(self, action, value):
        action.set_state(value)
        self.label.set_text(value.get_string())

    def change_base_theme_label(self, label):
        self.builder.get_object("current_selected_theme").set_label(f"Current Base Icon Theme: {label}")

    def make_themes_list(self):
        #self.change_base_theme_label(self.base_theme)

        theme = list()
        available_base_icon_themes = {}

        for path in BASE_THEME_DIRS:
            if Path(path).exists():
                log.debug(f"Searching {path} for Icon themes")
                for folder in Path(path).iterdir():
                    if folder.is_dir():
                        #log.debug(f"Searching {str(folder)} for index.theme")
                        if str(folder) not in theme:
                            theme_file = folder / "index.theme"
                            if theme_file.exists():
                                #log.debug(f"Reading {str(theme_file)}")
                                config = configparser.ConfigParser(strict=False, allow_no_value = True)
                                config.read(str(theme_file))
                                if config.has_section("Icon Theme"):
                                    # We've found an icon theme!
                                    if folder.name in ["hicolor", "default"] or not config.has_option("Icon Theme", "Directories"):
                                        #skip defaults
                                        continue
                                    if config.has_option("Icon Theme", "Name"):
                                        name = f'{config["Icon Theme"]["Name"]}'
                                    else:
                                        name = folder.name
                                    log.debug(f"Adding Icon theme {name}, (Folder: {folder.name}, Path: {str(folder)}")
                                    theme.append(str(folder))
                                    #self.available_icon_themes.append([name, folder.name,str(folder)])
                                    #self.available_icon_themes.append([name, folder.name,str(folder)])
                                    available_base_icon_themes[str(folder)] = {"folder":folder.name, "name": name}
        return(available_base_icon_themes)

    def change_context(self, radiobutton=None, label=None):

        if label:
            
            log.debug(f"Changing view to {label}")
            
            self.global_context = label.get_string()
            radiobutton.set_state(label)
            
            if label.get_string() == "All":
                log.debug("Setting Global Context to None")
                self.global_context = None

            if self.searchbar.get_search_mode():
                if self.search_button.get_active():
                    self.search_button.set_active(False)
                self.searchbar.set_search_mode(False)
        self.update_available_icons()
    
    def change_theme(self, radiobutton, label=None):
        theme_folder_name = label.get_string()
        status_string = f'Changing Base Theme to "{self.available_themes[theme_folder_name]["name"]}" Path: {theme_folder_name}'
        log.debug(status_string)
        radiobutton.set_state(label)
        self.update_status_bar(message=status_string)
        self.base_theme = self.available_themes[theme_folder_name]["folder"]
        Gtk.Settings.get_default().set_property("gtk-icon-theme-name", self.base_theme ) 
        
        log.debug("Refreshing Icons after base theme change")
        self.icons_list = list()
        self.update_all_icons()
        self.get_theme()
        self.update_available_icons()
        self.apply_theme_file_changes()
        self.apply_changes()

    def new_from_base(self, action=None, variant=None):
        log.debug(f"New from {self.base_theme}")
        self.save_button(False)
        self.changes = dict()
        self.theme_file_changes = dict()
        self.theme_name = ''
        self.theme_comment = ''
        self.theme_config_file = configparser.ConfigParser()
        self.theme_config_file.optionxform = str
        self.theme_config_file.read_string(THEME_HEADER)
        self.theme_file_path = '' 
        self.icons_list = list()       
        self.update_all_icons()
        self.get_theme()
        self.update_available_icons()

    def show_about(self, action, param):
        about_dialog = Gtk.AboutDialog(transient_for=self.window, modal=True)
        about_dialog.present()

    def build_menu_logic(self):

        log.debug("Building Headerbar Menus")
        self.builder.add_from_string(menu_def)
        self.make_context_menu()
        
        main_menu = self.builder.get_object('button_header_menu')
        main_menu.set_menu_model(self.builder.get_object('preference_menu'))

        quit = Gio.SimpleAction.new("quit")
        quit.connect("activate", self.quit)
        self.window.add_action(quit)

        about = Gio.SimpleAction.new("show_about")
        about.connect("activate", self.show_about)
        self.window.add_action(about)

        open_theme = Gio.SimpleAction.new("open_theme")
        open_theme.connect("activate", self.open_theme)
        self.window.add_action(open_theme)

        open_theme_menu_item = Gio.SimpleAction.new("theme_options_window")
        open_theme_menu_item.connect("activate", self.theme_options_window)
        self.window.add_action(open_theme_menu_item)

        new_menu_button = Gio.SimpleAction.new("new")
        new_menu_button.connect("activate", self.new_from_base)
        self.window.add_action(new_menu_button)

        self.save_menuitem = Gio.SimpleAction.new("save")
        self.save_menuitem.connect("activate", self.save)
        self.save_menuitem.set_enabled(False)
        self.window.add_action(self.save_menuitem)

        self.save_as_menuitem = Gio.SimpleAction.new("save_as")
        self.save_as_menuitem.connect("activate", self.save_as)
        self.save_as_menuitem.set_enabled(False)
        self.window.add_action(self.save_as_menuitem)

        copy = Gio.SimpleAction.new("copy")
        copy.connect("activate", self.copy)
        self.set_accels_for_action("win.copy", ["c"])
        self.window.add_action(copy)

        paste = Gio.SimpleAction.new("paste")
        paste.connect("activate", self.paste)
        self.set_accels_for_action("win.paste", ["v"])
        self.window.add_action(paste)

        self.right_click_menu_button = Gtk.Menu.new_from_model(self.builder.get_object('right_click_menu'))
        self.right_click_menu_button.attach_to_widget(self.builder.get_object("select_icons"))

        self.make_base_theme_menu()
        
    def make_base_theme_menu(self):
        base_theme_submenu = self.builder.get_object('base_theme_submenu')

        self.available_themes = self.make_themes_list()

        for icon_theme in self.available_themes:
            log.debug(f'Preferences: Adding Icon Theme: {icon_theme}: {self.available_themes[icon_theme]["folder"], self.available_themes[icon_theme]["name"]}')
            theme_menuitem = Gio.MenuItem.new(self.available_themes[icon_theme]["name"], f"win.change-base-theme::{icon_theme}")
            base_theme_submenu.append_item(theme_menuitem)

            # get the current theme name
            if self.available_themes[icon_theme]["folder"] == self.base_theme:
                base_theme = icon_theme

        self.change_context_action = Gio.SimpleAction.new_stateful("change-base-theme", GLib.VariantType.new("s"), GLib.Variant("s", base_theme))
        self.change_context_action.connect("activate", self.change_theme)
        self.window.add_action(self.change_context_action)


    def make_context_menu(self):

        context_menu_button = self.builder.get_object('context_button')

        context_menu = self.builder.get_object('icon_context_menu')

        contexts = list()

        for context in self.ALL_ICONS:
            contexts.append(context)
        contexts.sort()

        for context in contexts:
            log.debug(f"Context: {context}")
            context_menuitem = Gio.MenuItem.new(context, f"win.change-context::{context}")
            context_menu.append_item(context_menuitem)
        

        self.change_context_menu_radio = Gio.SimpleAction.new_stateful("change-context", GLib.VariantType.new("s"), GLib.Variant("s", "Typical"))
        self.change_context_menu_radio.connect("activate", self.change_context)
        self.window.add_action(self.change_context_menu_radio)

        context_menu_button.set_menu_model(self.builder.get_object('icon_context_menu'))

    def image2pixbuf(self, im):
        data = im.tobytes()
        data = GLib.Bytes.new(data)
        has_alpha = im.mode=="RGBA"
        width, height = im.size
        rowstride = width * (3+int(has_alpha))
        pix = GdkPixbuf.Pixbuf.new_from_bytes(
                data, # Image data in 8-bit/sample packed format inside a GLib.Bytes
                GdkPixbuf.Colorspace.RGB, 
                has_alpha, # Whether the data has an opacity channel 
                8, # Number of bits per sample Max 8
                width, 
                height, 
                rowstride
            )
        return pix

    def save_button(self, sensitivity):
        log.debug(f"Setting save sensitivity to {sensitivity}")
        self.save_as_menuitem.set_enabled(sensitivity)
        self.save_menuitem.set_enabled(sensitivity)
        self.builder.get_object("save").set_sensitive(sensitivity)

#### Icon Theme Options Window
    def theme_options_window(self, action, variant):
        log.debug("Creating Theme Options Window")
        self.options_window = Gtk.Window()
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)

        label1 = Gtk.Label(label="Theme Name:")
        label1.set_halign(1)

        label2 = Gtk.Label(label="Theme Comment:")
        label2.set_halign(1)

        self.theme_options_name = Gtk.Entry()
        self.theme_options_name.set_text(self.theme_config_file['Icon Theme']['Name'])
        self.theme_options_name.connect("activate", self.theme_options_ok)

        self.theme_options_comment = Gtk.Entry()
        self.theme_options_comment.set_text(self.theme_config_file['Icon Theme']['Comment'])
        self.theme_options_comment.connect("activate", self.theme_options_ok)
        
        vbox.pack_start(label1, True, True, 0)
        vbox.pack_start(self.theme_options_name, True, True, 0)
        vbox.pack_start(label2, True, True, 0)
        vbox.pack_start(self.theme_options_comment, True, True, 0)

        if self.theme_file_path:
            theme_path = Gtk.Label(label=f"Theme Path:{self.theme_file_path}")
            theme_path.set_halign(1)
            vbox.pack_start(theme_path, True, True, 0)
        # else:
        #     self.theme_options_comment.set_margin_bottom(10)
        vbox.set_margin_bottom(10)
        vbox.set_margin_top(10)
        vbox.set_margin_end(10)
        vbox.set_margin_start(10)

        hb = Gtk.HeaderBar()
        hb.set_show_close_button(False)
        hb.props.title = f"Theme Settings"
        hb.set_subtitle("Change theme name and comment")
        self.options_window.set_titlebar(hb)

        button = Gtk.Button(label="Ok")
        button.connect("clicked", self.theme_options_ok)
        hb.pack_end(button)
        button = Gtk.Button(label="Cancel")
        button.connect("clicked", self.theme_options_cancel)
        hb.pack_start(button)

        self.options_window.add(vbox)
        self.options_window.show_all()

    def theme_options_ok(self, button):

        if self.theme_config_file['Icon Theme']['Name'] != self.theme_options_name.get_text():
            log.debug(f"New Theme Name: {self.theme_options_name.get_text()}")
            self.theme_config_file['Icon Theme']['Name'] = self.theme_options_name.get_text()
            self.save_button(True)

        if self.theme_config_file['Icon Theme']['Comment'] != self.theme_options_comment.get_text():
            log.debug(f"New Theme Comment: {self.theme_options_comment.get_text()}")
            self.theme_config_file['Icon Theme']['Comment'] = self.theme_options_comment.get_text()
            self.save_button(True)
        self.options_window.destroy()

    def theme_options_cancel(self, button):
        self.options_window.destroy()

log.setLevel(logging.WARNING)

desc = 'GTK Icon Theme Editor and Builder. Supports JPG, PNG, ICO, ICL, DLL and EXE files.'
arg_parser = argparse.ArgumentParser(description=desc)
arg_parser.add_argument('-d', '--debug', help="Print debugging statements", action="store_const", dest="loglevel", const=logging.DEBUG, default=logging.WARNING)
arg_parser.add_argument("-t","--theme", help="Icon index.theme file to open", default=None)
arg_parser.add_argument("-s", "--dont-show-symbolics", help="Do not show symbolic icons", default=True, action="store_false")
arg_parser.add_argument("-a", "--all", help="Default view of all icons", default=False, action="store_true")
args = arg_parser.parse_args()

log.setLevel(args.loglevel)

context = "Typical"
if args.all:
    context = None

win = IconTheme(filename=args.theme, show_symbolics=args.dont_show_symbolics,context=context)
Gtk.main()